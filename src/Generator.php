<?php declare(strict_types=1);

namespace Inferred;

use Exception;
use Inferred\Collections\StringList;
use Inferred\PhpDoc\DocComment;
use Inferred\PhpDoc\SimpleTag;
use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\Method;
use Nette\PhpGenerator\Property;

class Generator
{
    protected string $path;
    protected ?string $namespace;

    public function __construct(string $directoryPath, ?string $namespace = null)
    {
        if (!file_exists($directoryPath) || !is_writable($directoryPath)) {
            throw new Exception("Path '$directoryPath' doesn't exist or not writable.");
        }
        $this->path = $directoryPath;
        $this->namespace = $namespace;
    }

    public function generate(Schema $schema)
    {
        $class = new ClassType($schema->getName());
        if ($schema->hasParent()) {
            $class->setExtends($schema->getParent());
        }

        $comment = $schema->getDocComment();
        if (!$comment) {
            $comment = new DocComment();
        }
        $comment->addTag(new SimpleTag("autogenerated", date('Y-m-d H:i:s')));
        $class->addComment($comment->toString());

        $methods = $schema->getMethods();
        foreach ($methods as $methodSchema) {
            $newMethod = $class->addMethod($methodSchema->getName());
            $newMethod->setAbstract($methodSchema->isAbstract());
            $newMethod->setFinal($methodSchema->isFinal());
            if (!$methodSchema->isAbstract()) {
                $newMethod->setBody($methodSchema->getBody());
            }
            $this->includeIFieldFeatures($methodSchema, $newMethod);

            $parameters = $methodSchema->getParameters();
            foreach ($parameters as $parameterSchema) {
                $newParameter = $newMethod->addParameter($parameterSchema->getName());

                if ($parameterSchema->getType()) {
                    $newParameter->setType($parameterSchema->getType()->toString());
                    $newParameter->setNullable($parameterSchema->getType()->isNullable());
                }
                if ($parameterSchema->hasDefaultValue()) {
                    $newParameter->setDefaultValue($parameterSchema->getDefaultValue()->getValue());
                }
            }
        }

        $fields = $schema->getFields();
        foreach ($fields as $field) {
            $prop = $class->addProperty($field->getName());
            if ($field->getDefaultValue()) {
                $prop->setValue($field->getDefaultValue()->getValue());
            }
            $this->includeIFieldFeatures($field,$prop);
        }

        $header = $this->createFileHeader($schema);
        $code = $header . $class;
        $this->createFile($code, $schema);
    }

    protected function createFileHeader(Schema $schema): string
    {
        $result = new StringList();
        $opening = $this->generateOpeningPhpTag($schema);
        $result->add($opening);
        $result->add('');

        $namespace = $this->resolveFileNamespace($schema);
        if ($namespace) {
            $result->add("namespace $namespace;");
            $result->add('');
        }

        $namespaces = $schema->getUsedNamespaces();
        if (count($namespaces) > 0) {
            foreach ($namespaces as $namespace) {
                $result->add("use $namespace;");
            }
            $result->add('');
        }
        $result->add('');
        return $result->join("\n");
    }

    protected function generateOpeningPhpTag(Schema $schema): string
    {
        $result = '<?php';
        if ($schema->isStrict()) {
            $result .= ' declare(strict_types=1);';
        }
        return $result;
    }

    protected function createFile(string $code, Schema $schema)
    {
        $extraDirs = [];
        $namespace = $this->resolveFileNamespace($schema);
        if ($namespace) {
            $fromRoot = substr($namespace, strlen($this->namespace));
            $extraDirs = explode("\\", $fromRoot);
        }
        $dirPath = $this->path;
        foreach ($extraDirs as $dir) {
            $dirPath .= "/" . $dir;
            if (is_dir($dirPath) && is_writable($dirPath)) {
                continue;
            }
            if (is_dir($dirPath) && !is_writable($dirPath)) {
                throw new Exception("Directory '$dirPath' is not writable.");
            }
            mkdir($dirPath);
        }

        $filename = $schema->getName() . ".php";
        $filepath = $this->path . "/" . $filename;
        if ($extraDirs) {
            $filepath = $this->path . "/" . join("/", $extraDirs) . "/" . $filename;
        }
        if (file_exists($filepath)) {
            unlink($filepath);
        }

        file_put_contents($filepath, $code);
    }

    protected function resolveFileNamespace(Schema $schema): ?string
    {
        $namespace = $schema->getNamespace();
        //if schema doesn't have a namespace, use generator's namespace
        if (!$namespace) {
            $namespace = $this->namespace;
        }

        //Generator has to have namespace, since there might be many schemas and there will be conflicts
        if ($namespace && !$this->namespace) {
            throw new Exception("Generator has to have a namespace in order to use namespaces in schemas. Schemas namespaces must match the Generator namespace.");
        }

        if ($namespace) {
            if (!str_starts_with($namespace, $this->namespace)) {
                throw new Exception("Schema namespace doesn't match Generator namespace.");
            }
        }
        return $namespace;
    }

    protected function includeIFieldFeatures(IField $fieldSchema, Method|Property $netteField)
    {
        $netteField->setVisibility($fieldSchema->getVisibility()->toString());
        if ($fieldSchema->getDocComment()) {
            $netteField->addComment($fieldSchema->getDocComment()->toString());
        }
        $netteField->setStatic($fieldSchema->isStatic());

        if (!$fieldSchema->getType()) {
            return;
        }
        if ($netteField instanceof Method) {
            $netteField->setReturnType($fieldSchema->getType()->toString());
        } else {
            $netteField->setType($fieldSchema->getType()->toString());
        }
    }
}
